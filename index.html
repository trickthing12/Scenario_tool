<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Scenario</title>
    <style>
        /* --- 기본 스타일 --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Pretendard', sans-serif; overflow: hidden; background-color: #f4f4f4; }

        /* --- 상단 UI 레이어 --- */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 60px;
            background: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 1000; display: flex; justify-content: space-between; align-items: center; padding: 0 20px;
        }

        /* 좌측 컨트롤 그룹 (제목 + 저장/불러오기) */
        .control-group { display: flex; align-items: center; gap: 15px; }

        #scenario-title {
            font-size: 1.2rem; font-weight: bold; border: none; border-bottom: 2px solid #ddd;
            padding: 5px; width: 250px; outline: none; transition: border-color 0.3s;
        }
        #scenario-title:focus { border-bottom-color: #333; }

        /* 버튼 스타일 */
        .btn {
            padding: 8px 16px; border: 1px solid #ccc; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.9rem;
        }
        .btn:hover { background: #f0f0f0; }
        .btn-primary { background: #333; color: white; border: none; }
        .btn-primary:hover { background: #555; }

        /* --- 우측 메뉴 --- */
        #menu-container { position: relative; }
        #hamburger-icon { font-size: 24px; cursor: pointer; padding: 10px; }
        
        #object-palette {
            display: none; position: absolute; top: 50px; right: 0;
            background: white; border: 1px solid #ddd; border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); padding: 10px; width: 160px;
            flex-direction: column; gap: 10px;
        }
        #menu-container:hover #object-palette { display: flex; }

        .draggable-item {
            padding: 10px; background: #eee; border-radius: 4px; cursor: grab;
            text-align: center; font-size: 0.9rem; user-select: none;
        }
        .draggable-item:hover { background: #ddd; }

        /* --- 메인 워크스페이스 --- */
        #workspace {
            position: absolute; top: 60px; left: 0; right: 0; bottom: 0;
            overflow: auto; background-color: #f9f9f9;
        }

        #timeline-container {
            position: relative; width: 2000px; height: 100%; min-width: 100%;
        }

        #central-line {
            position: absolute; top: 50%; left: 0; width: 100%; height: 4px;
            background-color: #333; transform: translateY(-50%); z-index: 0;
        }

        #extend-btn {
            position: absolute; top: 50%; right: -50px; transform: translateY(-50%);
            padding: 10px 20px; background: #333; color: white; border: none;
            border-radius: 20px; cursor: pointer; z-index: 10;
        }

        /* --- 배치된 객체 공통 스타일 --- */
        .placed-object {
            position: absolute; padding: 10px; border-radius: 8px; cursor: move; z-index: 5;
            min-width: 100px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex; align-items: center; justify-content: space-between; gap: 8px;
        }

        /* 텍스트 편집 영역 */
        .editable-text { outline: none; border-bottom: 1px dashed transparent; min-width: 50px; }
        .editable-text:focus { border-bottom: 1px dashed #999; }

        /* 컬러 피커 스타일 */
        .color-picker {
            width: 20px; height: 20px; border: none; cursor: pointer; background: none; padding: 0;
        }

        /* 타입별 스타일 */
        /* 1. Title: 배경 투명, 글자 큼 */
        .obj-title { background: transparent; border: 2px dashed #ccc; font-size: 1.5rem; font-weight: bold; }
        
        /* 2. Incident: 사각형 박스 */
        .obj-incident { background: #fff; border: 2px solid #333; font-size: 0.9rem; }
        
        /* 3. Character: 둥근 모서리 or 원형 느낌 */
        .obj-char { background: #e3f2fd; border: 2px solid #2196f3; border-radius: 30px; font-size: 0.9rem; font-weight: bold; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="control-group">
            <input type="text" id="scenario-title" placeholder="시나리오 제목 입력">
            
            <button class="btn btn-primary" onclick="saveScenario()">저장 (Save)</button>
            <label for="file-load" class="btn">불러오기 (Load)</label>
            <input type="file" id="file-load" accept=".json" style="display: none;" onchange="loadScenario(this)">
        </div>

        <div id="menu-container">
            <div id="hamburger-icon">☰</div>
            <div id="object-palette">
                <div class="draggable-item" draggable="true" data-type="title">Title (제목)</div>
                <div class="draggable-item" draggable="true" data-type="incident">Incident (사건/사고)</div>
                <div class="draggable-item" draggable="true" data-type="char">Character (캐릭터)</div>
            </div>
        </div>
    </div>

    <div id="workspace">
        <div id="timeline-container">
            <div id="central-line"></div>
            <button id="extend-btn" title="타임라인 늘리기">+</button>
        </div>
    </div>

    <script>
        // --- 기본 변수 및 설정 ---
        const workspace = document.getElementById('workspace');
        const timelineContainer = document.getElementById('timeline-container');
        const extendBtn = document.getElementById('extend-btn');
        const titleInput = document.getElementById('scenario-title');
        const draggables = document.querySelectorAll('.draggable-item');

        // 제목 변경 시 페이지 타이틀 동기화
        titleInput.addEventListener('input', (e) => {
            document.title = e.target.value || "New Scenario";
        });

        // 타임라인 확장
        extendBtn.addEventListener('click', () => {
            timelineContainer.style.width = (timelineContainer.offsetWidth + 1000) + 'px';
        });

        // --- 드래그 앤 드롭 로직 ---
        let draggedType = null;

        draggables.forEach(item => {
            item.addEventListener('dragstart', (e) => {
                draggedType = e.target.getAttribute('data-type');
                e.dataTransfer.effectAllowed = "copy";
            });
        });

        workspace.addEventListener('dragover', (e) => e.preventDefault());

        workspace.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!draggedType) return;
            
            const rect = timelineContainer.getBoundingClientRect();
            const x = e.clientX - rect.left + workspace.scrollLeft; 
            const y = e.clientY - rect.top + workspace.scrollTop; 

            // 초기값 설정
            let defaultText = "Title";
            let defaultColor = "#000000";
            
            if (draggedType === 'incident') { defaultText = "사건/사고"; defaultColor = "#ffffff"; }
            if (draggedType === 'char') { defaultText = "캐릭터 이름"; defaultColor = "#e3f2fd"; }

            createObject(draggedType, x, y, defaultText, defaultColor);
            draggedType = null;
        });

        // --- 객체 생성 함수 (통합 규칙 적용) ---
        function createObject(type, x, y, textContent, colorValue) {
            const el = document.createElement('div');
            el.classList.add('placed-object');
            
            // 타입별 클래스 추가
            if (type === 'title') el.classList.add('obj-title');
            else if (type === 'incident') el.classList.add('obj-incident');
            else if (type === 'char') el.classList.add('obj-char');
            
            // 위치 설정
            el.style.left = x + 'px';
            el.style.top = y + 'px';

            // 데이터 속성 저장 (저장 기능을 위해)
            el.dataset.type = type;

            // 1. 텍스트 영역 (수정 가능)
            const span = document.createElement('span');
            span.classList.add('editable-text');
            span.innerText = textContent;
            span.contentEditable = true;
            
            // 2. 컬러 피커
            const colorInput = document.createElement('input');
            colorInput.type = "color";
            colorInput.classList.add('color-picker');
            colorInput.value = colorValue || "#000000"; // 초기값

            // 초기 색상 적용 로직
            applyColor(el, type, colorInput.value);

            // 색상 변경 이벤트
            colorInput.addEventListener('input', (e) => {
                applyColor(el, type, e.target.value);
            });

            el.appendChild(span);
            el.appendChild(colorInput);
            
            // 드래그 기능 연결
            makeElementDraggable(el);
            
            timelineContainer.appendChild(el);
        }

        // 색상 적용 헬퍼 함수
        function applyColor(element, type, color) {
            if (type === 'title') {
                element.style.color = color; // 제목은 글자색 변경
            } else {
                element.style.backgroundColor = color; // 나머지는 배경색 변경
            }
        }

        // --- 드래그 이동 로직 (기존과 동일) ---
        function makeElementDraggable(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            elmnt.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                if(e.target.isContentEditable || e.target.tagName === 'INPUT') return;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // --- 저장 및 불러오기 기능 ---

        // 1. 저장 (Save)
        function saveScenario() {
            const title = titleInput.value || "MyScenario";
            const width = timelineContainer.style.width;
            const objects = [];

            document.querySelectorAll('.placed-object').forEach(obj => {
                const text = obj.querySelector('.editable-text').innerText;
                const color = obj.querySelector('.color-picker').value;
                objects.push({
                    type: obj.dataset.type,
                    left: obj.style.left,
                    top: obj.style.top,
                    text: text,
                    color: color
                });
            });

            const data = {
                title: title,
                timelineWidth: width,
                items: objects
            };

            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const link = document.createElement('a');
            
            link.href = URL.createObjectURL(blob);
            link.download = `${title}.json`;
            link.click();
        }

        // 2. 불러오기 (Load)
        function loadScenario(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // 기존 화면 초기화
                    titleInput.value = data.title || "";
                    document.title = data.title || "New Scenario";
                    if (data.timelineWidth) timelineContainer.style.width = data.timelineWidth;
                    
                    // 기존 객체 삭제 (선과 버튼 제외)
                    const existingObjs = document.querySelectorAll('.placed-object');
                    existingObjs.forEach(el => el.remove());

                    // 객체 재생성
                    if (data.items && Array.isArray(data.items)) {
                        data.items.forEach(item => {
                            // 저장된 좌표에서 'px' 제거 후 숫자 변환 (createObject가 px를 다시 붙임)
                            // 하지만 여기서는 이미 px가 붙어있을 수 있으므로 처리
                            createObject(item.type, item.left, item.top, item.text, item.color);
                            
                            // createObject는 좌표를 받아서 style.left = x + 'px'로 처리함.
                            // 저장된 데이터가 "100px" 형태라면 위 로직 수정 필요.
                            // -> 아래에서 수동으로 위치 재조정 (안전하게)
                            const lastObj = timelineContainer.lastElementChild;
                            lastObj.style.left = item.left;
                            lastObj.style.top = item.top;
                        });
                    }
                    alert("성공적으로 불러왔습니다!");
                } catch (err) {
                    alert("파일을 읽는 중 오류가 발생했습니다: " + err);
                }
            };
            reader.readAsText(file);
            input.value = ''; // 같은 파일 다시 선택 가능하게 초기화
        }

    </script>
</body>
</html>
