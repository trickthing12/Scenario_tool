<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Planner</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f4f9;
            --sidebar-bg: #ffffff;
            --surface-color: #ffffff;
            --border-color: #e5e7eb;
            --primary-color: #1a73e8;
            --text-color: #1f1f1f;
            --shadow-sm: 0 1px 2px 0 rgba(0,0,0,0.05);
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); overflow: hidden; display: flex; height: 100vh; }

        /* --- 1. 좌측 사이드바 (설명서) --- */
        #sidebar {
            width: 300px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            z-index: 2000;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .brand { font-size: 1.2rem; font-weight: 700; color: var(--primary-color); margin-bottom: 20px; display: flex; align-items: center; gap: 8px; }
        .guide-box { background: #f8f9fa; border-radius: 12px; padding: 15px; margin-bottom: 15px; font-size: 0.9rem; line-height: 1.5; color: #444; }
        .guide-title { font-weight: 700; margin-bottom: 8px; color: #333; }
        .guide-list li { margin-bottom: 5px; margin-left: 20px; }

        /* --- 2. 메인 컨텐츠 영역 --- */
        #main-content { flex-grow: 1; display: flex; flex-direction: column; position: relative; }

        /* 헤더 */
        #header {
            height: 60px; background: rgba(255,255,255,0.9); backdrop-filter: blur(5px);
            border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
        }

        .header-left { display: flex; align-items: center; gap: 10px; }
        #scenario-title {
            font-size: 1.1rem; font-weight: 600; border: none; background: transparent; padding: 5px; outline: none; width: 300px;
        }
        #scenario-title:hover { background: #f1f1f1; border-radius: 4px; }

        .btn { padding: 8px 16px; border-radius: 20px; border: 1px solid var(--border-color); background: white; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.2s; }
        .btn:hover { background: #f8f9fa; box-shadow: var(--shadow-sm); }
        .btn-primary { background: var(--text-color); color: white; border: none; }
        .btn-primary:hover { background: #333; }

        /* 햄버거 메뉴 & 팔레트 */
        #menu-container { position: relative; }
        #hamburger-icon { cursor: pointer; padding: 8px; border-radius: 50%; transition: background 0.2s; }
        #hamburger-icon:hover { background: #eee; }
        
        #object-palette {
            display: none; position: absolute; top: 50px; right: 0;
            background: white; border: 1px solid var(--border-color); border-radius: 12px;
            box-shadow: var(--shadow-md); padding: 10px; width: 180px;
            flex-direction: column; gap: 8px; z-index: 3000;
        }
        #menu-container:hover #object-palette { display: flex; }

        .draggable-item {
            padding: 10px; background: #f8f9fa; border-radius: 8px; cursor: grab; text-align: center; font-size: 0.9rem; font-weight: 500;
            transition: background 0.2s;
        }
        .draggable-item:hover { background: #e9ecef; }

        /* --- 3. 워크스페이스 (타임라인) --- */
        #workspace { flex-grow: 1; position: relative; overflow: auto; background-color: var(--bg-color); cursor: grab; }
        #workspace:active { cursor: grabbing; }

        #timeline-container {
            position: relative; width: 3000px; height: 100%; min-width: 100%;
        }

        /* SVG 레이어 (선 그리기용) - 객체보다 뒤, 배경보다 앞 */
        #svg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; /* 클릭 통과 */
        }
        /* SVG 내부의 선과 텍스트는 클릭 가능해야 함 */
        .connection-line { stroke: #999; stroke-width: 2; fill: none; pointer-events: stroke; cursor: pointer; transition: stroke 0.2s; }
        .connection-line:hover { stroke: var(--primary-color); stroke-width: 3; }
        .line-text { fill: #666; font-size: 12px; background: white; pointer-events: none; text-anchor: middle; }
        
        /* 중앙선 */
        #central-line {
            position: absolute; top: 50%; left: 0; width: 100%; height: 2px;
            background-color: #cbd5e1; z-index: 0;
        }

        #extend-btn {
            position: absolute; top: 50%; right: -60px; transform: translateY(-50%);
            width: 40px; height: 40px; border-radius: 50%; background: white; border: 1px solid #ccc;
            cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 10;
            box-shadow: var(--shadow-sm); font-size: 1.5rem; color: #555;
        }

        /* --- 4. 배치된 객체 스타일 --- */
        .placed-object {
            position: absolute; padding: 12px 16px; border-radius: 12px; cursor: move; z-index: 10;
            min-width: 120px; box-shadow: var(--shadow-md); display: flex; flex-direction: column; gap: 8px;
            background: white; border: 1px solid transparent; transition: box-shadow 0.2s;
        }
        .placed-object:hover { box-shadow: 0 8px 12px rgba(0,0,0,0.1); z-index: 100; }
        .placed-object:hover .anchor { opacity: 1; } /* 호버 시 연결 점 표시 */

        /* 내용물 */
        .obj-header { display: flex; align-items: center; justify-content: space-between; width: 100%; gap: 10px; }
        .editable-text { outline: none; min-width: 50px; line-height: 1.4; }
        .color-picker { width: 18px; height: 18px; border: none; cursor: pointer; background: none; border-radius: 50%; overflow: hidden; padding: 0; }

        /* 타입별 스타일 */
        .obj-title { background: transparent; border: 2px dashed #ccc; box-shadow: none; min-width: auto; }
        .obj-title .editable-text { font-size: 1.8rem; font-weight: 800; color: #333; }
        
        .obj-incident { background: #ffffff; border: 1px solid #ddd; border-left: 4px solid #333; }
        .obj-incident .editable-text { font-size: 0.95rem; font-weight: 500; }
        
        .obj-char { background: #e8f0fe; border: 1px solid #d2e3fc; border-radius: 50px; padding: 10px 20px; align-items: center; flex-direction: row; }
        .obj-char .editable-text { font-size: 0.95rem; font-weight: 600; color: #1967d2; text-align: center; }

        /* 메모 객체 (신규) */
        .obj-memo { 
            background: #fff9c4; border: 1px solid #fbc02d; 
            min-width: 150px; min-height: 100px;
            resize: both; overflow: auto; /* 크기 조절 가능 */
        }
        .obj-memo .editable-text { width: 100%; height: 100%; font-size: 0.9rem; color: #555; }

        /* 떡밥 마커 (신규) */
        .bait-marker {
            width: 20px; height: 20px; border-radius: 50%; background: #eee; color: #999;
            display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; font-weight: bold;
        }
        .bait-marker.active { background: #ff5252; color: white; }

        /* 연결 점 (Anchors) */
        .anchor {
            position: absolute; width: 10px; height: 10px; background: #999; border-radius: 50%;
            cursor: crosshair; opacity: 0; transition: opacity 0.2s; z-index: 101;
        }
        .anchor:hover { transform: scale(1.5); background: var(--primary-color); }
        .anchor.active { background: #ff5252; opacity: 1; transform: scale(1.5); } /* 선택된 점 */

        .anchor.top { top: -5px; left: 50%; transform: translateX(-50%); }
        .anchor.bottom { bottom: -5px; left: 50%; transform: translateX(-50%); }
        .anchor.left { top: 50%; left: -5px; transform: translateY(-50%); }
        .anchor.right { top: 50%; right: -5px; transform: translateY(-50%); }

    </style>
</head>
<body>

    <div id="sidebar">
        <div class="brand">
            <span>✨ Scenario Planner</span>
        </div>
        
        <div class="guide-box">
            <div class="guide-title">기본 조작</div>
            <ul class="guide-list">
                <li>우측 상단 <strong>☰ 메뉴</strong>에서 객체를 드래그하여 타임라인에 배치하세요.</li>
                <li>텍스트를 클릭하여 내용을 수정할 수 있습니다.</li>
                <li>오른쪽 끝의 <strong>+ 버튼</strong>을 누르면 타임라인이 길어집니다.</li>
            </ul>
        </div>

        <div class="guide-box">
            <div class="guide-title">객체 연결 (선 그리기)</div>
            <ul class="guide-list">
                <li>객체에 마우스를 올리면 4방향에 <strong>점(Anchor)</strong>이 생깁니다.</li>
                <li>점을 클릭(빨강) 후, 다른 객체의 점을 클릭하면 연결됩니다.</li>
                <li><strong>연결된 선을 클릭</strong>하면 점선/실선 변경 및 텍스트 입력이 가능합니다.</li>
            </ul>
        </div>

        <div class="guide-box">
            <div class="guide-title">특수 기능</div>
            <ul class="guide-list">
                <li><strong>사건/사고:</strong> 우측 상단의 <code>?</code> 버튼을 눌러 '미해결 떡밥(붉은 느낌표)'을 표시하세요.</li>
                <li><strong>설명(메모):</strong> 우측 하단을 드래그하여 상자 크기를 조절할 수 있습니다.</li>
            </ul>
        </div>
        
        <div style="margin-top: auto; font-size: 0.8rem; color: #888;">
            v 2.0.0 (Offline Mode)
        </div>
    </div>

    <div id="main-content">
        <div id="header">
            <div class="header-left">
                <input type="text" id="scenario-title" placeholder="무제 시나리오">
            </div>
            
            <div style="display: flex; align-items: center; gap: 15px;">
                <button class="btn" onclick="saveScenario()">저장 (Save)</button>
                <label for="file-load" class="btn">불러오기 (Load)</label>
                <input type="file" id="file-load" accept=".json" style="display: none;" onchange="loadScenario(this)">
                
                <div id="menu-container">
                    <div id="hamburger-icon">☰</div>
                    <div id="object-palette">
                        <div class="draggable-item" draggable="true" data-type="title">Title (제목)</div>
                        <div class="draggable-item" draggable="true" data-type="incident">Incident (사건/사고)</div>
                        <div class="draggable-item" draggable="true" data-type="char">Character (캐릭터)</div>
                        <div class="draggable-item" draggable="true" data-type="memo">Description (설명)</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="workspace">
            <div id="timeline-container">
                <svg id="svg-layer"></svg> <div id="central-line"></div>
                <button id="extend-btn" title="타임라인 늘리기">+</button>
            </div>
        </div>
    </div>

    <script>
        // --- 유틸리티: UUID 생성 ---
        function uuid() {
            return 'xxxx-xxxx-xxxx-xxxx'.replace(/[x]/g, () => (Math.random()*16|0).toString(16));
        }

        // --- 전역 변수 ---
        const workspace = document.getElementById('workspace');
        const timelineContainer = document.getElementById('timeline-container');
        const svgLayer = document.getElementById('svg-layer');
        const titleInput = document.getElementById('scenario-title');
        let lines = []; // 선 데이터 저장소
        let activeAnchor = null; // 현재 선택된 연결 시작점

        // --- 초기 설정 ---
        titleInput.addEventListener('input', (e) => document.title = e.target.value || "Scenario Planner");
        
        // 타임라인 확장
        document.getElementById('extend-btn').addEventListener('click', () => {
            timelineContainer.style.width = (timelineContainer.offsetWidth + 1000) + 'px';
            updateAllLines(); // 선 길이 재계산을 위해
        });

        // --- 드래그 앤 드롭 (객체 생성) ---
        let draggedType = null;
        document.querySelectorAll('.draggable-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                draggedType = e.target.getAttribute('data-type');
            });
        });

        workspace.addEventListener('dragover', (e) => e.preventDefault());
        workspace.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!draggedType) return;
            const rect = timelineContainer.getBoundingClientRect();
            const x = e.clientX - rect.left + workspace.scrollLeft; 
            const y = e.clientY - rect.top + workspace.scrollTop; 
            createObject({ type: draggedType, x, y });
            draggedType = null;
        });

        // --- 객체 생성 함수 ---
        function createObject(params) {
            // params: { id, type, x, y, text, color, isBait, width, height }
            const id = params.id || uuid();
            const el = document.createElement('div');
            el.id = id;
            el.classList.add('placed-object');
            el.dataset.type = params.type;
            el.style.left = params.x + 'px';
            el.style.top = params.y + 'px';
            
            // 타입별 클래스 및 기본값
            let defaultText = "Text";
            let defaultColor = "#000000";

            if (params.type === 'title') {
                el.classList.add('obj-title');
                defaultText = "Title";
            } else if (params.type === 'incident') {
                el.classList.add('obj-incident');
                defaultText = "사건/사고";
            } else if (params.type === 'char') {
                el.classList.add('obj-char');
                defaultText = "캐릭터";
            } else if (params.type === 'memo') {
                el.classList.add('obj-memo');
                defaultText = "자유롭게 내용을 작성하세요.";
                if(params.width) el.style.width = params.width;
                if(params.height) el.style.height = params.height;
            }

            // 헤더 컨테이너 (텍스트 + 컨트롤)
            const header = document.createElement('div');
            header.classList.add('obj-header');

            // 텍스트 영역
            const span = document.createElement('span');
            span.classList.add('editable-text');
            span.innerText = params.text || defaultText;
            span.contentEditable = true;
            header.appendChild(span);

            // 우측 컨트롤 (떡밥마커 or 컬러픽커)
            const controls = document.createElement('div');
            controls.style.display = 'flex';
            controls.style.gap = '5px';
            controls.style.alignItems = 'center';

            // 떡밥 마커 (사건/사고 전용)
            if (params.type === 'incident') {
                const baitBtn = document.createElement('div');
                baitBtn.classList.add('bait-marker');
                baitBtn.innerText = "?";
                if (params.isBait) {
                    baitBtn.classList.add('active');
                    baitBtn.innerText = "!";
                }
                baitBtn.onclick = (e) => {
                    e.stopPropagation(); // 드래그 방지
                    baitBtn.classList.toggle('active');
                    baitBtn.innerText = baitBtn.classList.contains('active') ? "!" : "?";
                };
                controls.appendChild(baitBtn);
            }

            // 컬러 피커
            const colorInput = document.createElement('input');
            colorInput.type = "color";
            colorInput.classList.add('color-picker');
            colorInput.value = params.color || "#ffffff";
            colorInput.addEventListener('input', (e) => applyColor(el, params.type, e.target.value));
            controls.appendChild(colorInput);

            header.appendChild(controls);
            el.appendChild(header);

            // 초기 색상 적용
            applyColor(el, params.type, colorInput.value);

            // 연결 포인트 (Anchors) 추가 - Top, Bottom, Left, Right
            ['top', 'bottom', 'left', 'right'].forEach(pos => {
                const anchor = document.createElement('div');
                anchor.classList.add('anchor', pos);
                anchor.dataset.pos = pos;
                anchor.dataset.parentId = id;
                anchor.onclick = (e) => handleAnchorClick(e, anchor);
                el.appendChild(anchor);
            });

            // 드래그 기능
            makeElementDraggable(el);
            timelineContainer.appendChild(el);
        }

        function applyColor(el, type, color) {
            if (type === 'title') el.querySelector('.editable-text').style.color = color;
            else if (type === 'incident') el.style.borderLeftColor = color;
            else el.style.backgroundColor = color;
        }

        // --- 연결 로직 (Connection Logic) ---
        function handleAnchorClick(e, anchor) {
            e.stopPropagation(); // 드래그 시작 방지
            
            if (activeAnchor) {
                // 이미 시작점이 있는 상태 -> 연결 시도
                if (activeAnchor === anchor) {
                    // 자기 자신 클릭 -> 취소
                    activeAnchor.classList.remove('active');
                    activeAnchor = null;
                } else {
                    // 연결 생성
                    createLine(activeAnchor, anchor);
                    activeAnchor.classList.remove('active');
                    activeAnchor = null;
                }
            } else {
                // 시작점 선택
                activeAnchor = anchor;
                activeAnchor.classList.add('active');
            }
        }

        function createLine(startAnchor, endAnchor, existingData = null) {
            const lineId = existingData ? existingData.id : uuid();
            const lineData = existingData || {
                id: lineId,
                from: startAnchor.dataset.parentId,
                fromPos: startAnchor.dataset.pos,
                to: endAnchor.dataset.parentId,
                toPos: endAnchor.dataset.pos,
                style: 'solid', // solid or dashed
                text: ''
            };
            
            if (!existingData) lines.push(lineData);

            // SVG 요소 생성
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.id = lineId;
            g.style.pointerEvents = 'stroke'; // 그룹 전체 이벤트

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.classList.add('connection-line');
            if (lineData.style === 'dashed') path.style.strokeDasharray = "5,5";
            
            // 선 클릭 이벤트 (스타일 변경 및 텍스트)
            path.addEventListener('click', (e) => {
                e.stopPropagation();
                const newText = prompt("선 위에 표시할 텍스트를 입력하세요 (취소 시 스타일 토글):", lineData.text);
                
                if (newText !== null) {
                    lineData.text = newText;
                } else {
                    // 텍스트 입력 취소 시 스타일 토글
                    lineData.style = lineData.style === 'solid' ? 'dashed' : 'solid';
                }
                updateLineVisual(lineId);
            });

            // 텍스트 라벨
            const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textEl.classList.add('line-text');
            textEl.textContent = lineData.text;

            g.appendChild(path);
            g.appendChild(textEl);
            svgLayer.appendChild(g);

            updateSingleLine(lineData);
        }

        function updateAllLines() {
            lines.forEach(line => updateSingleLine(line));
        }

        function updateSingleLine(lineData) {
            const elFrom = document.getElementById(lineData.from);
            const elTo = document.getElementById(lineData.to);
            if (!elFrom || !elTo) return; // 객체가 삭제된 경우

            const p1 = getAnchorPos(elFrom, lineData.fromPos);
            const p2 = getAnchorPos(elTo, lineData.toPos);

            const g = document.getElementById(lineData.id);
            if (!g) return;
            const path = g.querySelector('path');
            const text = g.querySelector('text');

            // 베지어 곡선 그리기
            const dx = Math.abs(p1.x - p2.x) * 0.5;
            const d = `M ${p1.x} ${p1.y} C ${p1.x + dx} ${p1.y}, ${p2.x - dx} ${p2.y}, ${p2.x} ${p2.y}`;
            
            path.setAttribute("d", d);
            if (lineData.style === 'dashed') path.style.strokeDasharray = "5,5";
            else path.style.strokeDasharray = "none";

            // 텍스트 위치 (곡선 중간)
            text.setAttribute("x", (p1.x + p2.x) / 2);
            text.setAttribute("y", (p1.y + p2.y) / 2 - 5); // 약간 위로
            text.textContent = lineData.text;
        }

        function getAnchorPos(el, pos) {
            const rect = el.getBoundingClientRect(); // 뷰포트 기준
            const containerRect = timelineContainer.getBoundingClientRect(); // 컨테이너 기준
            
            // 컨테이너 내부의 상대 좌표 계산 (스크롤 포함)
            const left = el.offsetLeft;
            const top = el.offsetTop;
            const w = el.offsetWidth;
            const h = el.offsetHeight;

            if (pos === 'top') return { x: left + w/2, y: top };
            if (pos === 'bottom') return { x: left + w/2, y: top + h };
            if (pos === 'left') return { x: left, y: top + h/2 };
            if (pos === 'right') return { x: left + w, y: top + h/2 };
            return { x: left, y: top };
        }

        function updateLineVisual(lineId) {
            const lineData = lines.find(l => l.id === lineId);
            if (lineData) updateSingleLine(lineData);
        }

        // --- 객체 드래그 로직 ---
        function makeElementDraggable(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = elmnt.querySelector('.obj-header') || elmnt;
            
            // 텍스트나 인풋 클릭 시 드래그 방지
            elmnt.onmousedown = (e) => {
                if (e.target.isContentEditable || e.target.tagName === 'INPUT' || e.target.classList.contains('anchor') || e.target.classList.contains('bait-marker')) return;
                dragMouseDown(e);
            };

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                
                // 드래그 중인 객체를 맨 위로
                elmnt.style.zIndex = 100; 
            }

            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
                
                updateAllLines(); // 이동 중 선 업데이트
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
                elmnt.style.zIndex = 10;
            }
        }

        // --- 저장 및 불러오기 ---
        function saveScenario() {
            const title = titleInput.value || "MyScenario";
            const objects = [];

            document.querySelectorAll('.placed-object').forEach(obj => {
                const text = obj.querySelector('.editable-text').innerText;
                const colorInput = obj.querySelector('.color-picker');
                const bait = obj.querySelector('.bait-marker');
                
                objects.push({
                    id: obj.id,
                    type: obj.dataset.type,
                    left: parseInt(obj.style.left),
                    top: parseInt(obj.style.top),
                    text: text,
                    color: colorInput ? colorInput.value : null,
                    isBait: bait ? bait.classList.contains('active') : false,
                    width: obj.style.width,
                    height: obj.style.height
                });
            });

            const data = {
                title: title,
                width: timelineContainer.style.width,
                objects: objects,
                lines: lines
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${title}.json`;
            link.click();
        }

        function loadScenario(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // 초기화
                    titleInput.value = data.title || "";
                    document.title = data.title || "Scenario Planner";
                    timelineContainer.style.width = data.width || "3000px";
                    
                    // 객체 삭제
                    document.querySelectorAll('.placed-object').forEach(el => el.remove());
                    // 선 삭제
                    svgLayer.innerHTML = '';
                    lines = [];

                    // 객체 복원
                    data.objects.forEach(item => {
                        createObject({
                            id: item.id,
                            type: item.type,
                            x: item.left,
                            y: item.top,
                            text: item.text,
                            color: item.color,
                            isBait: item.isBait,
                            width: item.width,
                            height: item.height
                        });
                    });

                    // 선 복원
                    if (data.lines) {
                        data.lines.forEach(lineData => {
                            // DOM이 그려진 후 연결하기 위해 잠시 대기할 필요 없음 (동기 처리됨)
                            const fromEl = document.getElementById(lineData.from);
                            const toEl = document.getElementById(lineData.to);
                            if(fromEl && toEl) {
                                const startAnchor = fromEl.querySelector(`.anchor.${lineData.fromPos}`);
                                const endAnchor = toEl.querySelector(`.anchor.${lineData.toPos}`);
                                createLine(startAnchor, endAnchor, lineData);
                            }
                        });
                    }

                } catch (err) {
                    alert("파일 오류: " + err);
                    console.error(err);
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

    </script>
</body>
</html>
