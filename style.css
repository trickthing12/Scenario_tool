// --- 유틸리티 ---
function uuid() { return 'xxxx-xxxx-xxxx-xxxx'.replace(/[x]/g, () => (Math.random()*16|0).toString(16)); }

const workspace = document.getElementById('workspace');
const timelineContainer = document.getElementById('timeline-container');
const svgLayer = document.getElementById('svg-layer');
const titleInput = document.getElementById('scenario-title');
const zoomIndicator = document.getElementById('zoom-indicator');

let lines = []; 
let activeAnchor = null;
let draggedType = null;
let scale = 1; // 현재 줌 배율 (기본 1)

// --- 초기화 ---
titleInput.addEventListener('input', (e) => document.title = e.target.value || "Scenario Planner");

// 타임라인 길이 연장
document.getElementById('extend-btn').addEventListener('click', () => {
    timelineContainer.style.width = (timelineContainer.offsetWidth + 1000) + 'px';
    updateAllLines();
});

// --- 5. 줌 (확대/축소) 로직 ---
workspace.addEventListener('wheel', (e) => {
    if (e.ctrlKey) {
        e.preventDefault(); // 기본 브라우저 줌 방지
        const zoomStep = 0.1;
        if (e.deltaY < 0) {
            scale = Math.min(scale + zoomStep, 5); // 최대 5배
        } else {
            scale = Math.max(scale - zoomStep, 0.5); // 최소 0.5배
        }
        
        timelineContainer.style.transform = `scale(${scale})`;
        zoomIndicator.innerText = `${Math.round(scale * 100)}%`;
        
        // 줌 변경 시 선 위치 재계산이 필요할 수 있으나 CSS transform이므로 자동 적용됨.
    }
}, { passive: false });

// --- 드래그 앤 드롭 (객체 생성) ---
document.querySelectorAll('.draggable-item').forEach(item => {
    item.addEventListener('dragstart', (e) => draggedType = e.target.getAttribute('data-type'));
});

workspace.addEventListener('dragover', (e) => e.preventDefault());
workspace.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggedType) return;
    
    // 줌 상태를 고려한 좌표 계산
    const rect = timelineContainer.getBoundingClientRect();
    // 마우스 위치에서 컨테이너 시작점을 빼고, 스케일로 나누어야 원본 좌표계 값이 나옴
    const x = (e.clientX - rect.left) / scale;
    const y = (e.clientY - rect.top) / scale;
    
    createObject({ type: draggedType, x, y });
    draggedType = null;
});

// --- 객체 생성 ---
function createObject(params) {
    const id = params.id || uuid();
    const el = document.createElement('div');
    el.id = id;
    el.classList.add('placed-object');
    el.dataset.type = params.type;
    el.style.left = params.x + 'px';
    el.style.top = params.y + 'px';
    
    // 타입별 설정
    let defaultText = "Text";
    let defaultColor = "#ffffff";

    if (params.type === 'title') {
        el.classList.add('obj-title');
        defaultText = "TITLE";
        defaultColor = "#000000";
    } else if (params.type === 'incident') {
        el.classList.add('obj-incident');
        defaultText = "사건 내용";
        defaultColor = "#ffffff";
    } else if (params.type === 'char') {
        el.classList.add('obj-char');
        defaultText = "캐릭터명";
        defaultColor = "#e3f2fd";
    } else if (params.type === 'memo') {
        el.classList.add('obj-memo');
        defaultText = "메모를 입력하세요";
        defaultColor = "#fff9c4";
        if(params.width) el.style.width = params.width;
        if(params.height) el.style.height = params.height;
    }

    // HTML 구조
    const header = document.createElement('div');
    header.classList.add('obj-header');
    
    const span = document.createElement('span');
    span.classList.add('editable-text');
    span.innerText = params.text || defaultText;
    span.contentEditable = true;
    header.appendChild(span);

    // 컨트롤
    const controls = document.createElement('div');
    controls.style.display = 'flex';
    controls.style.gap = '5px';
    controls.style.alignItems = 'center';

    if (params.type === 'incident') {
        const baitBtn = document.createElement('div');
        baitBtn.classList.add('bait-marker');
        baitBtn.innerText = "?";
        if (params.isBait) { baitBtn.classList.add('active'); baitBtn.innerText = "!"; }
        baitBtn.onclick = (e) => {
            e.stopPropagation();
            baitBtn.classList.toggle('active');
            baitBtn.innerText = baitBtn.classList.contains('active') ? "!" : "?";
        };
        controls.appendChild(baitBtn);
    }

    const colorInput = document.createElement('input');
    colorInput.type = "color";
    colorInput.classList.add('color-picker');
    colorInput.value = params.color || defaultColor;
    colorInput.addEventListener('input', (e) => applyColor(el, params.type, e.target.value));
    controls.appendChild(colorInput);

    header.appendChild(controls);
    el.appendChild(header);
    
    applyColor(el, params.type, colorInput.value);

    // 앵커 추가
    ['top', 'bottom', 'left', 'right'].forEach(pos => {
        const anchor = document.createElement('div');
        anchor.classList.add('anchor', pos);
        anchor.dataset.pos = pos;
        anchor.dataset.parentId = id;
        anchor.onclick = (e) => handleAnchorClick(e, anchor);
        el.appendChild(anchor);
    });

    makeElementDraggable(el);
    timelineContainer.appendChild(el);
}

function applyColor(el, type, color) {
    if (type === 'title') el.querySelector('.editable-text').style.color = color;
    else if (type === 'incident') el.style.borderLeftColor = color;
    else el.style.backgroundColor = color;
}

// --- 연결 로직 ---
function handleAnchorClick(e, anchor) {
    e.stopPropagation();
    if (activeAnchor) {
        if (activeAnchor !== anchor) {
            createLine(activeAnchor, anchor);
            activeAnchor.classList.remove('active');
            activeAnchor = null;
        }
    } else {
        activeAnchor = anchor;
        activeAnchor.classList.add('active');
    }
}

function createLine(startAnchor, endAnchor, existingData = null) {
    const lineId = existingData ? existingData.id : uuid();
    const lineData = existingData || {
        id: lineId,
        from: startAnchor.dataset.parentId,
        fromPos: startAnchor.dataset.pos,
        to: endAnchor.dataset.parentId,
        toPos: endAnchor.dataset.pos,
        style: 'solid',
        text: ''
    };
    if (!existingData) lines.push(lineData);

    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.id = lineId;
    
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.classList.add('connection-line');
    if (lineData.style === 'dashed') path.style.strokeDasharray = "5,5";
    
    path.addEventListener('click', (e) => {
        e.stopPropagation();
        const newText = prompt("선 텍스트 (취소 시 점선/실선 토글):", lineData.text);
        if (newText !== null) lineData.text = newText;
        else lineData.style = lineData.style === 'solid' ? 'dashed' : 'solid';
        updateLineVisual(lineId);
    });

    const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
    textEl.classList.add('line-text');
    textEl.textContent = lineData.text;

    g.appendChild(path);
    g.appendChild(textEl);
    svgLayer.appendChild(g);
    updateSingleLine(lineData);
}

function updateSingleLine(lineData) {
    const elFrom = document.getElementById(lineData.from);
    const elTo = document.getElementById(lineData.to);
    if (!elFrom || !elTo) return;

    // 줌을 고려하지 않은 순수 DOM 좌표 필요 (SVG가 컨테이너 안에 있으므로)
    const p1 = getAnchorPos(elFrom, lineData.fromPos);
    const p2 = getAnchorPos(elTo, lineData.toPos);
    
    const g = document.getElementById(lineData.id);
    if (!g) return;
    const path = g.querySelector('path');
    const text = g.querySelector('text');

    const dx = Math.abs(p1.x - p2.x) * 0.5;
    const d = `M ${p1.x} ${p1.y} C ${p1.x + dx} ${p1.y}, ${p2.x - dx} ${p2.y}, ${p2.x} ${p2.y}`;
    
    path.setAttribute("d", d);
    path.style.strokeDasharray = lineData.style === 'dashed' ? "5,5" : "none";
    text.setAttribute("x", (p1.x + p2.x) / 2);
    text.setAttribute("y", (p1.y + p2.y) / 2 - 5);
    text.textContent = lineData.text;
}

function updateAllLines() { lines.forEach(updateSingleLine); }

function getAnchorPos(el, pos) {
    const left = el.offsetLeft;
    const top = el.offsetTop;
    const w = el.offsetWidth;
    const h = el.offsetHeight;
    if (pos === 'top') return { x: left + w/2, y: top };
    if (pos === 'bottom') return { x: left + w/2, y: top + h };
    if (pos === 'left') return { x: left, y: top + h/2 };
    if (pos === 'right') return { x: left + w, y: top + h/2 };
    return { x: left, y: top };
}

function updateLineVisual(lineId) {
    const l = lines.find(x => x.id === lineId);
    if(l) updateSingleLine(l);
}

// --- 객체 이동 (드래그) ---
function makeElementDraggable(elmnt) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    
    elmnt.onmousedown = (e) => {
        if (e.target.isContentEditable || e.target.tagName === 'INPUT' || e.target.classList.contains('anchor') || e.target.classList.contains('bait-marker')) return;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
        elmnt.style.zIndex = 100;
    };

    function elementDrag(e) {
        e.preventDefault();
        // 줌 상태에서는 마우스 이동량도 스케일로 나눠줘야 함
        const deltaX = (e.clientX - pos3) / scale;
        const deltaY = (e.clientY - pos4) / scale;
        
        pos3 = e.clientX;
        pos4 = e.clientY;

        elmnt.style.top = (elmnt.offsetTop + deltaY) + "px";
        elmnt.style.left = (elmnt.offsetLeft + deltaX) + "px";
        updateAllLines();
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
        elmnt.style.zIndex = 10;
    }
}

// --- 저장/불러오기 ---
function saveScenario() {
    const title = titleInput.value || "MyScenario";
    const objects = [];
    document.querySelectorAll('.placed-object').forEach(obj => {
        objects.push({
            id: obj.id, type: obj.dataset.type,
            left: parseFloat(obj.style.left), top: parseFloat(obj.style.top),
            text: obj.querySelector('.editable-text').innerText,
            color: obj.querySelector('.color-picker').value,
            isBait: obj.querySelector('.bait-marker')?.classList.contains('active') || false,
            width: obj.style.width, height: obj.style.height
        });
    });

    const data = { title, width: timelineContainer.style.width, objects, lines };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${title}.json`;
    link.click();
}

function loadScenario(input) {
    const file = input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            titleInput.value = data.title || "";
            timelineContainer.style.width = data.width || "3000px";
            
            document.querySelectorAll('.placed-object').forEach(el => el.remove());
            svgLayer.innerHTML = '';
            lines = [];

            data.objects.forEach(item => createObject({
                id: item.id, type: item.type, x: item.left, y: item.top, 
                text: item.text, color: item.color, isBait: item.isBait, 
                width: item.width, height: item.height
            }));

            if (data.lines) {
                data.lines.forEach(line => {
                   const f = document.getElementById(line.from);
                   const t = document.getElementById(line.to);
                   if(f && t) createLine(f.querySelector(`.anchor.${line.fromPos}`), t.querySelector(`.anchor.${line.toPos}`), line);
                });
            }
        } catch (err) { alert("오류: " + err); }
    };
    reader.readAsText(file);
    input.value = '';
}
